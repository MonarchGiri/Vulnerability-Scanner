import sys
import os
import subprocess
import re
import argparse
import glob
from math import floor
from datetime import datetime
from nmap import PortScanner
from lxml import etree
from PyQt6.QtCore import (Qt, QFile, QTextStream, QIODevice, QTimer, QUrl)
from PyQt6.QtGui import (QDesktopServices, QIcon, QTextCursor, QStandardItemModel, QStandardItem, QColor, QTextCharFormat, QTextDocument, QFont)
from PyQt6.QtWidgets import (QApplication, QMainWindow, QPushButton, QStyleFactory, QTableWidgetItem, QDialog, QWidget, QVBoxLayout, QTableWidget, QHBoxLayout, QAbstractItemView, QListWidget, QSplitter, QTextBrowser, QListWidgetItem, QMessageBox)
from PyQt6.QtWebEngineWidgets import QWebEngineView
from res.login_dialog import LoginDialog
from res.auth import Auth
from res.main_window import Ui_MainWindow
from res.vuln_dialog import Ui_VulnsDialog
from res.scheduler import SchedulerDialog
from res.searchsploit import SearchSploitWidget
from res.nmap_utils import (NmapProcess, setup_profiles, highlight_rules, custom_split, remove_argument, exclude_args_dict)
from res.email_utils import send_verification_email
from res.email_utils import send_scan_report_email



# Function to save HTML content in a date-wise sub-directory with a time-wise stamp
def save_output_html(content):
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    time_str = now.strftime("%H-%M-%S")
    
    base_directory = os.path.join("Results", date_str)
    if not os.path.exists(base_directory):
        os.makedirs(base_directory)
    
    file_name = f"output_{time_str}.html"
    file_path = os.path.join(base_directory, file_name)
    
    with open(file_path, "w") as file:
        file.write(content)
    
    print(f"Output saved to {file_path}")
    return file_path

# Initialize the database
auth_instance = Auth()
auth_instance.init_db()

# Script Metadata
script_name = os.path.basename(sys.modules['__main__'].__file__)
script_dir = os.path.abspath(os.path.dirname(sys.modules['__main__'].__file__))
print(f"Script name: {script_name}")
print(f"Script directory: {script_dir}")

# Loading Content into Text Browser or Web Engine View
def load_content_into_view(view, resource_path, is_html=False):
    file = QFile(resource_path)
    if not file.open(QIODevice.OpenModeFlag.ReadOnly | QIODevice.OpenModeFlag.Text):
        return

    stream = QTextStream(file)
    content = stream.readAll()
    file.close()

    if is_html and isinstance(view, QWebEngineView):
        view.setHtml(content)
    elif not is_html and isinstance(view, QTextBrowser):
        document = QTextDocument()
        document.setMarkdown(content)
        view.setDocument(document)
        view.setOpenExternalLinks(True)
    else:
        if is_html:
            view.setHtml(content)
        else:
            document = QTextDocument()
            document.setMarkdown(content)
            view.setDocument(document)
        view.setOpenExternalLinks(True)

# Converting URLs to Hyperlinks
def linkify(text):
    url_pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
    lines = text.splitlines()
    processed_lines = [url_pattern.sub(r'<a href="\g<0>">\g<0></a>', line) for line in lines]
    return '<br>'.join(processed_lines)

def cron_finished(output_filename, output_xml, generate_html, sender=None):
    if not output_filename:
        output_filename = "NextgeNmap-cronjob"

    name, extension = os.path.splitext(output_filename)
    print(f"cron_finished: {name}, {extension}")

    # Read our temporary XML file into memory
    with open(output_xml, 'r') as f:
        xml_data = f.read()

    if generate_html:
        if extension != '.html':
            output_filename = name + '.html'

        # Load the XSL stylesheet
        bootstrap_path = os.path.join(script_dir, 'res', 'nmap-bootstrap.xsl')
        with open(bootstrap_path, 'r') as f:
            xsl = f.read()

        # Parse the XML and XSL strings into etree objects
        xml_root = etree.fromstring(xml_data.encode())
        xsl_root = etree.fromstring(xsl.encode())

        # Create an XSLT transformer
        transformer = etree.XSLT(xsl_root)

        # Apply the transformation to the XML and save the HTML output
        html_root = transformer(xml_root)
        final_report = str(html_root)
        
        # Save the output using the new function
        final_report_path = save_output_html(final_report)
        output_filename = final_report_path
    else:
        if extension != '.xml':
            output_filename = name + '.xml'
        final_report = xml_data

    with open(output_filename, 'w') as f:
        f.write(final_report)

    # Ensure the .xml file is removed
    if output_xml and os.path.exists(output_xml):
        try:
            os.remove(output_xml)
            print(f"Removed temporary XML file: {output_xml}")
        except Exception as e:
            print(f"Error removing {output_xml}: {e}")

    # Send email with the report
    smtp_settings = sender.main_window.scheduler_dialog.smtp_settings
    receiver_email = smtp_settings['receiver']
    username = auth_instance.get_username_by_email(receiver_email)  # Ensure correct auth_instance is used
    print(f"Fetched username: {username} for email: {receiver_email}")  # Debug print statement

    send_scan_report_email(
        smtp_settings['server'],
        smtp_settings['port'],
        smtp_settings['sender'],
        receiver_email,
        smtp_settings['password'],
        "Scan Report",
        f"Dear {username},\n\nScanning complete. Please find attached scanning report.",
        output_filename
    )

    # Load the recent report in the QWebEngineView
    if sender:
        sender.load_report_in_view(final_report_path)




# Appends items to a QStandardItemModel, marking separators.
def append_items(model, items, is_separator=False):
    for text in items:
        item = QStandardItem(text)
        if is_separator:
            item.setData("separator", Qt.ItemDataRole.UserRole)
            font = item.font()
            font.setBold(True)
            item.setForeground(QColor(0, 123, 255))
            item.setFont(font)
        model.appendRow(item)

# Custom model to handle separators.
class SeparatorStandardItemModel(QStandardItemModel):
    def flags(self, index):
        if self.itemFromIndex(index).data(Qt.ItemDataRole.UserRole) == "separator":
            return Qt.ItemFlag.NoItemFlags
        return super().flags(index)

# Dialog for displaying vulnerability results.
class VulnResultsDialog(QDialog, Ui_VulnsDialog):
    def __init__(self, parent=None, main_window=None):
        super().__init__(parent)
        self.setupUi(self)
        self.main_window = main_window
        self.init_ui()

    def init_ui(self):
        return

# Main GUI Class
class NextgeNmapGUI(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        script_dir = os.path.abspath(os.path.dirname(__file__))
        icon_path = os.path.join(script_dir, 'icon.jpeg')
        app_icon = QIcon(icon_path)
        self.setWindowIcon(app_icon)
        self.auth = auth_instance  # Use the initialized auth instance
        self.latest_report = None  # Initialize latest_report attribute
        self.setupUi(self)
        self.actionExit.triggered.connect(lambda: QApplication.quit())
        self.actionToggle_Dark_Mode.triggered.connect(self.toggle_dark_mode)
        self.profile_model = SeparatorStandardItemModel(self)
        self.script_model = SeparatorStandardItemModel(self)
        self.scheduler_dialog = SchedulerDialog(parent=self, main_window=self)
        self.vuln_dialog = VulnResultsDialog(parent=self, main_window=self)
        self.searchsploit = SearchSploitWidget(parent=self)
        self.nmap_results = None
        self.host_ports_tables = {}
        self.buffered_output = ""
        self.dark_mode_enabled = False
        self.update_output_text()
        self.show_login_dialog()

        load_content_into_view(self.about_web_view, os.path.join(script_dir, "about_updated.html"), is_html=True)  # Using QWebEngineView
        load_content_into_view(self.help_web_view, os.path.join(script_dir, "helpdocs.html"), is_html=True)  # Load helpdocs.html

        self.tab_widget.insertTab(2, self.searchsploit, "SearchSploit")

        # Nmap Output Tab Connections
        self.open_in_browser_button.clicked.connect(self.open_recent_report_in_browser)

        # Previous HTML Reports Tab Connections
        self.load_previous_reports()

        self.previous_reports_list.itemClicked.connect(self.load_selected_report)

        self.recent_report_view = QWebEngineView()


    def load_report_in_view(self, file_path):
        if os.path.exists(file_path):
            print(f"Loading HTML content from {file_path} into QWebEngineView.")
            self.recent_report_view.setUrl(QUrl.fromLocalFile(file_path))
        else:
            print(f"File {file_path} does not exist.")

    def open_recent_report_in_browser(self):
        try:
            file_path = self.latest_report
            if file_path:
                QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
            else:
                QMessageBox.warning(self, "Error", "No recent report found.")
        except AttributeError:
            QMessageBox.warning(self, "Error", "No recent report found.")


    def load_recent_report(self):
        results_dir = os.path.join("Results")
        if not os.path.exists(results_dir):
            print("Results directory does not exist.")
            return
        
        latest_file = max(glob.glob(os.path.join(results_dir, '**/*.html'), recursive=True), key=os.path.getctime, default=None)
        self.latest_report = latest_file
        if latest_file:
            print(f"Loading recent report: {latest_file}")
            load_content_into_view(self.recent_report_view, latest_file, is_html=True)
        else:
            print("No HTML report found.")

    def load_previous_reports(self):
        self.previous_reports_list.clear()
        results_dir = os.path.join("Results")
        if not os.path.exists(results_dir):
            return
        
        for root, dirs, files in os.walk(results_dir):
            for file in files:
                if file.endswith(".html"):
                    file_path = os.path.join(root, file)
                    file_display = f"{os.path.basename(root)} - {file}"
                    list_item = QListWidgetItem(file_display)
                    list_item.setData(Qt.ItemDataRole.UserRole, file_path)
                    self.previous_reports_list.addItem(list_item)

    def load_selected_report(self, item):
        file_path = item.data(Qt.ItemDataRole.UserRole)
        QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))

    def show_login_dialog(self):
        if not self.auth.user_exists():
            login_dialog = LoginDialog(parent=self, auth=self.auth, create_account=True)
        else:
            login_dialog = LoginDialog(parent=self, auth=self.auth)
        
        login_dialog.login_successful.connect(self.initialize_ui)
        if login_dialog.exec() == QDialog.DialogCode.Rejected and not login_dialog.login_successful.isSignalConnected():
            self.close()

    def initialize_ui(self, username):
        if not username:
            self.close()
            return

        QMessageBox.information(self, 'Welcome', f'Welcome, {username}!')
        setup_profiles(self)
        self.profile_combobox.setCurrentIndex(2)
        self.scan_button.clicked.connect(self.start_scan)
        self.cancel_button.clicked.connect(self.terminate_scan)
        self.target_entry.textChanged.connect(lambda: (self.update_command(), self.target_entry.setPlaceholderText("")))
        self.port_range_entry.textChanged.connect(lambda: (self.update_command()))
        self.vuln_scripts_combobox.currentIndexChanged.connect(lambda: (self.update_command(), self.script_args_entry.setText("")))
        self.command_entry.textChanged.connect(lambda: (self.update_target_from_command(), self.update_command()))
        self.script_args_entry.textChanged.connect(self.update_command)
        self.profile_combobox.currentIndexChanged.connect(self.update_command)
        self.verbose_checkbox.stateChanged.connect(self.update_command)
        self.verbose_spinbox.valueChanged.connect(self.update_command)
        self.schedule_button.clicked.connect(self.show_scheduler)
        self.hosts_list.currentRowChanged.connect(self.on_host_selected)
        self.nmap_progress.setVisible(False)
        self.statusbar.showMessage("Status: Idle")
        self.statusbar.setStyleSheet("QStatusBar{padding-left:8px;color:green;}")
        self.nmap_output_text.verticalScrollBar().setValue(self.nmap_output_text.verticalScrollBar().maximum())

        self.profile_model = SeparatorStandardItemModel(self)
        self.script_model = SeparatorStandardItemModel(self)
        self.profile_combobox.setModel(self.profile_model)
        self.vuln_scripts_combobox.setModel(self.script_model)
        append_items(self.profile_model, {"": {"": {"": ""}}})
        append_items(self.script_model, {"": {"": {"": ""}}})

        for category, profile_or_script_dict in self.profile_and_script_details.items():
            if "Zenmap" in category or "vGuard" in category:
                append_items(self.profile_model, [f"-- {category} --"], is_separator=True)
                append_items(self.profile_model, list(profile_or_script_dict.keys()))
            else:
                append_items(self.script_model, [f"-- {category} --"], is_separator=True)
                append_items(self.script_model, list(profile_or_script_dict.keys()))

        self.update_command()
        self.target_entry.setFocus()

    def toggle_dark_mode(self):
        if self.dark_mode_enabled:
            self.setStyleSheet("")
            self.nmap_output_text.setStyleSheet("background-color: white; color: black;")
        else:
            dark_mode_stylesheet = """
            QMainWindow {
                background-color: #2e2e2e;
                color: #ffffff;
            }
            QMenuBar, QMenu, QToolBar, QStatusBar {
                background-color: #3e3e3e;
                color: #ffffff;
            }
            QMenuBar::item, QMenu::item {
                background-color: transparent;
                color: #ffffff;
            }
            QMenuBar::item:selected, QMenu::item:selected {
                background-color: #4e4e4e;
            }
            QMenuBar::item:pressed, QMenu::item:pressed {
                background-color: #5e5e5e;
            }
            QTabWidget::pane, QTabBar::tab {
                background-color: #3e3e3e;
                color: #ffffff;
            }
            QTabBar::tab:selected {
                background-color: #4e4e4e;
            }
            QTabBar::tab:!selected {
                background-color: #3e3e3e;
            }
            QTextEdit, QTableWidget, QTreeView, QListView, QLineEdit, QComboBox, QPushButton, QLabel {
                background-color: #3e3e3e;
                color: #ffffff;
                border: 1px solid #4e4e4e;
            }
            QTextEdit:disabled, QTableWidget:disabled, QTreeView:disabled, QListView:disabled, QLineEdit:disabled, QComboBox:disabled, QPushButton:disabled, QLabel:disabled {
                color: #aaaaaa;
            }
            QScrollBar:vertical, QScrollBar:horizontal {
                background-color: #3e3e3e;
                border: 1px solid #4e4e4e;
            }
            QScrollBar::handle {
                background-color: #5e5e5e;
                border: 1px solid #4e4e4e;
            }
            QScrollBar::handle:hover {
                background-color: #6e6e6e;
            }
            QScrollBar::add-line, QScrollBar::sub-line {
                background-color: #3e3e3e;
                border: 1px solid #4e4e4e;
            }
            """
            self.setStyleSheet(dark_mode_stylesheet)
            self.nmap_output_text.setStyleSheet("background-color: #2e2e2e; color: #ffffff;")
        self.dark_mode_enabled = not self.dark_mode_enabled

    def show_scheduler(self):
        self.scheduler_dialog.schedule_scan()
        self.scheduler_dialog.exec()

    def show_vulns(self, vuln_list):
        self.vuln_dialog.vuln_tabs.clear()
        new_tab = QWidget()
        new_output_list = QListWidget()
        new_output_list.setMaximumWidth(300)

        for i in range(0, len(vuln_list), 2):
            script_name = vuln_list[i]
            item = QListWidgetItem(script_name)
            new_output_list.addItem(item)

        max_item_width = new_output_list.sizeHintForColumn(0)
        details_view = QTextBrowser()
        details_view.setHtml("Click on a script to view details")
        details_view.setOpenExternalLinks(True)
        splitter = QSplitter()
        splitter.addWidget(new_output_list)
        splitter.addWidget(details_view)
        splitter.setStretchFactor(0, 0)
        splitter.setStretchFactor(1, 1)
        splitter.setSizes([max_item_width, 100])

        layout = QVBoxLayout()
        layout.addWidget(splitter)
        new_tab.setLayout(layout)

        new_output_list.currentRowChanged.connect(lambda index: details_view.setHtml(linkify(vuln_list[index * 2 + 1])))

        self.vuln_dialog.vuln_tabs.addTab(new_tab, self.profile_combobox.currentText() + " - " + self.target_entry.text())
        self.vuln_dialog.exec()


    def update_output_text(self):
        if self.buffered_output:
            self.apply_highlight_rules(self.buffered_output)
            self.update_progress(self.buffered_output)
            self.buffered_output = ""
        QTimer.singleShot(500, self.update_output_text)

    def apply_highlight_rules(self, text):
        cursor = self.nmap_output_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        cursor.insertText(text)

        for rule_name in highlight_rules:
            rule = highlight_rules[rule_name]
            regex = rule["regex"]
            pattern = re.compile(regex, re.MULTILINE)

            for match in pattern.finditer(self.nmap_output_text.toPlainText()):
                start = match.start()
                end = match.end()

                cursor.setPosition(start)
                cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)

                format = QTextCharFormat()
                format.setFontWeight(QFont.Weight.Bold if rule["bold"] else QFont.Weight.Normal)
                format.setFontUnderline(rule["underline"])
                format.setForeground(QColor(rule["text"][0] // 257, rule["text"][1] // 257, rule["text"][2] // 257))
                cursor.setCharFormat(format)
                cursor.clearSelection()

        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.nmap_output_text.setTextCursor(cursor)
        self.nmap_output_text.ensureCursorVisible()

    def update_progress(self, text):
        progress_match = re.search(r'About ([\d.]+)% done', text)
        etc_match = re.search(r'ETC: (\d{2}:\d{2}) \((\d{1,2}:\d{2}:\d{2}) remaining\)', text)

        if progress_match:
            progress = floor(float(progress_match.group(1)))
            self.nmap_progress.setValue(progress)
            self.nmap_progress.setVisible(True) if not self.nmap_progress.isVisible() else None

        if etc_match:
            etc_time = etc_match.group(1)
            remaining_time = etc_match.group(2)
            self.statusbar.showMessage(f"ETC: {etc_time} (about {remaining_time} remaining)")

    def handle_stdout(self, data, sender=None):
        self.buffered_output += data

    def handle_stderr(self, data, sender=None):
        self.buffered_output += data

    def terminate_scan(self):
        if self.nmap_process:
            self.nmap_process.kill()
        self.scan_button.setEnabled(True)
        self.cancel_button.setEnabled(False)
        self.nmap_progress.setVisible(False)
        self.statusbar.showMessage("Status: Idle")

    def scan_error(self, error_message):
        self.nmap_output_text.append("Scan aborted! {}".format(error_message))
        self.terminate_scan()

    def scan_finished(self, output_filename, output_xml, generate_html, sender=None):
        self.nmap_results = PortScanner()
        with open(output_xml, 'r') as xml_blob:
            xml_root = None
            xml_data = xml_blob.read()
            try:
                self.nmap_results.analyse_nmap_xml_scan(xml_data)
                self.populate_ports_hosts_grid()
                xml_root = etree.fromstring(xml_data.encode())

                services_to_search = self.searchsploit.get_services_to_search(xml_root)
                for services in services_to_search.values():
                    self.buffered_output += (f"Running SearchSploit on services: {services}...\n")
                self.searchsploit.run_searchsploit_on_services(services_to_search)
                self.buffered_output += "Finished running SearchSploit\n"

                if generate_html:
                    final_report_path = self.generate_html_report(xml_data, output_filename)
                    self.latest_report = final_report_path  # Set the latest report path
                else:
                    final_report_path = None

                email_subject = "Nmap Scan Results"
                email_body = "Scanning complete. Please find attached scanning report."

                # Fetch username
                receiver_email = self.scheduler_dialog.smtp_settings['receiver']
                username = auth_instance.get_username_by_email(receiver_email)
                if not username:
                    username = receiver_email  # Fallback to email if username not found

                send_scan_report_email(
                    self.scheduler_dialog.smtp_settings['server'],
                    self.scheduler_dialog.smtp_settings['port'],
                    self.scheduler_dialog.smtp_settings['sender'],
                    self.scheduler_dialog.smtp_settings['receiver'],
                    self.scheduler_dialog.smtp_settings['password'],
                    email_subject,
                    email_body,
                    final_report_path,
                    username
                )

                # Load the recent scan report into the web view
                if final_report_path:
                    self.tab_widget.setCurrentIndex(0)  # Switch to Scan Results tab
                    load_content_into_view(self.recent_report_view, final_report_path, is_html=True)

            except Exception as e:
                print(str(e))

        if output_xml and os.path.exists(output_xml):
            try:
                os.remove(output_xml)
                print(f"Removed temporary XML file: {output_xml}")
            except Exception as e:
                print(f"Error removing {output_xml}: {e}")
        self.terminate_scan()
        
    def display_searchsploit_results(self, services_to_search):
        self.searchsploit.display_results(services_to_search)

    def generate_html_report(self, xml_data, output_filename):
        script_dir = os.path.abspath(os.path.dirname(__file__))
        xsl_path = os.path.join(script_dir, 'res', 'nmap-bootstrap.xsl')
        
        with open(xsl_path, 'r') as f:
            xsl_data = f.read()

        xml_root = etree.fromstring(xml_data.encode())
        xsl_root = etree.fromstring(xsl_data.encode())

        transform = etree.XSLT(xsl_root)
        html_tree = transform(xml_root)

        html_output = etree.tostring(html_tree, pretty_print=True, method='html').decode()
        
        return save_output_html(html_output)

    def start_scan(self):
        QTimer.singleShot(0, self._start_scan)

    def _start_scan(self):
        command = self.command_entry.text().strip()
        self.final_command_text.setText(command)
        self.nmap_process = NmapProcess(command, output_filename="output.xml", stdout_callback=self.handle_stdout, stderr_callback=self.handle_stderr, finished_callback=self.scan_finished, generate_html=True)
        self.nmap_process.run()

        self.tab_widget.setCurrentIndex(0)
        self.nmap_output_text.clear()
        cursor = self.nmap_output_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.Start)
        cursor.setCharFormat(QTextCharFormat())
        self.nmap_output_text.setTextCursor(cursor)
        self.nmap_output_text.moveCursor(QTextCursor.MoveOperation.End)
        self.scan_button.setEnabled(False)
        self.cancel_button.setEnabled(True)
        self.statusbar.showMessage("Status: Running scan...")

    def update_target_from_command(self):
        current_command = self.command_entry.text()
        command_parts = [t for t in current_command.strip().split(" ") if t]
        new_target = self.parse_target_hosts(command_parts)

        if new_target != self.target_entry.text():
            self.target_entry.blockSignals(True)
            self.target_entry.setText(new_target + " ")
            self.target_entry.blockSignals(False)

    def parse_target_hosts(self, command_parts):
        target_hosts = []
        skip_next = False

        for i, part in enumerate(command_parts):
            if skip_next:
                skip_next = False
                continue
            if part.startswith('-') or part in ['and', 'or', 'not']:
                found = False
                for args in exclude_args_dict:
                    if part in args:
                        found = True
                        skip_next = True
                        break
                if found:
                    continue
            elif i > 0:
                target_hosts.append(part)

        return ' '.join(target_hosts)

    def extract_script_args(self, command_parts):
        script_args_value = None
        if "--script-args" in command_parts:
            script_args_index = command_parts.index("--script-args")
            try:
                script_args_value = command_parts[script_args_index + 1]
            except IndexError:
                pass
        return script_args_value

    def update_command(self):
        if self.sender(): sender = self.sender().objectName()
        else: sender = None

        targets = [t for t in self.target_entry.text().strip().split(" ") if t]
        port_range = self.port_range_entry.text().replace(" ", ",")
        profile = self.profile_combobox.currentText()
        vuln_script = self.vuln_scripts_combobox.currentText()
        script_args_entry = self.script_args_entry.text()
        script_args_value = None
        command_list = []

        if profile in self.profile_and_script_details.get("Zenmap default profiles", {}).keys():
            command_list += custom_split(self.profile_and_script_details["Zenmap default profiles"][profile].get('nmap_args', ''))
            self.vuln_scripts_combobox.setEnabled("--script" not in command_list)
            self.vuln_scripts_combobox.setCurrentIndex(0 if "--script" in command_list else self.vuln_scripts_combobox.currentIndex())

        if profile in self.profile_and_script_details.get("vGuard developer profiles", {}).keys():
            command_list += custom_split(self.profile_and_script_details["vGuard developer profiles"][profile].get('nmap_args', ''))
            self.vuln_scripts_combobox.setEnabled("--script" not in command_list)
            self.vuln_scripts_combobox.setCurrentIndex(0 if "--script" in command_list else self.vuln_scripts_combobox.currentIndex())

        for script_category in ["scip AG Scripts", "vulnersCom Scripts", "nccgroup Scripts", "VGuards curated scripts"]:
            if vuln_script in self.profile_and_script_details.get(script_category, {}).keys():
                script_nmap_args = custom_split(self.profile_and_script_details[script_category][vuln_script].get('nmap_args', ''))
                script_args_value = script_args_entry if script_args_entry else " ".join(custom_split(self.profile_and_script_details[script_category][vuln_script].get('script_args', '')))
                command_list += script_nmap_args

            if "--script-args" not in command_list and script_args_value:
                command_list += ["--script-args", script_args_value]
            elif "--script-args" in command_list and script_args_value:
                command_list = remove_argument(command_list, "--script-args")
                command_list += ["--script-args", script_args_value]
            elif "--script-args" in command_list and not script_args_value:
                command_list = remove_argument(command_list, "--script-args")

        has_v_option = any([arg.startswith("-v") and set(arg) == {"-", "v"} for arg in command_list])
        self.verbose_checkbox.setEnabled(not has_v_option)
        self.verbose_spinbox.setEnabled(not has_v_option)
        if not has_v_option and self.verbose_checkbox.isChecked():
            verbosity = self.verbose_spinbox.value()
            command_list += ["-" + "v" * verbosity]

        self.port_range_entry.setEnabled("-F" not in command_list)
        if "-F" in command_list:
            self.port_range_entry.setPlaceholderText("Can't use with -F")
            self.port_range_entry.setText("")
            command_list = remove_argument(command_list, "-p")
        elif self.port_range_entry.placeholderText() == "Can't use with -F":
            self.port_range_entry.setPlaceholderText("")

        if port_range:
            self.port_range_entry.setPlaceholderText("")
            if "-p" not in command_list:
                command_list += ["-p", f"{port_range}"]
            else:
                command_list = remove_argument(command_list, "-p")
                command_list += ["-p", f"{port_range}"]

        proposed_args = ["nmap"] + command_list + targets
        if sender != "command_entry": self.command_entry.setText(" ".join(proposed_args))
        else:
            current_args = custom_split(self.command_entry.text())
            if current_args != proposed_args:
                self.profile_combobox.blockSignals(True)
                self.profile_combobox.setCurrentIndex(0)
                self.profile_combobox.blockSignals(False)
        self.script_args_entry.setText(self.extract_script_args(command_list))

    def create_host_page(self):
        new_host_widget = QWidget()
        new_host_layout = QVBoxLayout()
        new_ports_table = QTableWidget()
        new_horizontal_layout = QHBoxLayout()

        new_ports_table.setAlternatingRowColors(True)
        new_ports_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        new_ports_table.setColumnCount(8)
        new_ports_table.setHorizontalHeaderLabels(["Status", "Port", "Protocol", "State", "Service", "Script Output", "Version", "CPE"])

        new_horizontal_layout.addWidget(new_ports_table)
        new_host_layout.addLayout(new_horizontal_layout)
        new_host_widget.setLayout(new_host_layout)

        return new_host_widget, new_ports_table

    def on_host_selected(self, current_row):
        self.hosts_pages.setCurrentIndex(current_row)

    def populate_ports_hosts_grid(self):
        if not self.nmap_results:
            return

        host_row_num = 0

        for host in self.nmap_results.all_hosts():
            host_data = self.nmap_results[host]
            hostname = host_data['hostnames'][0]['name']

            if hostname:
                display_name = f"{hostname} ({host})"
            else:
                display_name = host
            if host not in self.host_ports_tables:
                host_widget, ports_table = self.create_host_page()
                widget_index = self.hosts_pages.addWidget(host_widget)
                self.hosts_list.insertItem(host_row_num, display_name)
                host_item = QTableWidgetItem(host)
                host_item.setToolTip(hostname)
                host_row_num += 1
                self.host_ports_tables[host] = {"widget_index": widget_index, "ports_table": ports_table}
            else:
                widget_index = self.host_ports_tables[host]["widget_index"]
                ports_table = self.host_ports_tables[host]["ports_table"]
                self.hosts_list.item(widget_index).setText(display_name)

            port_row_num = 0
            if host_data.state() == "up":
                ports_table.clearContents()
                ports_table.setRowCount(0)
                ports_list = []
                for proto in host_data.all_protocols():
                    lport = host_data[proto].keys()

                    for port in lport:
                        status = host_data[proto][port]["state"]
                        service = host_data[proto][port]["name"]
                        version = host_data[proto][port]["product"] + " " + host_data[proto][port]["version"]
                        cpe = host_data[proto][port]["cpe"]
                        script_output = host_data[proto][port].get('script', {})

                        port_data = {
                            "port": port,
                            "protocol": proto,
                            "status": status,
                            "service": service,
                            "version": version,
                            "cpe": cpe,
                            "script_output": script_output
                        }
                        if status != "closed":
                            ports_list.append(port_data)

                    unique_ports = list({(p['port'], p['protocol']): p for p in ports_list}.values())
                    sorted_ports = sorted(unique_ports, key=lambda x: (x['port'], x['protocol']))

                    for unique_data in sorted_ports:
                        ports_table.insertRow(port_row_num)
                        ports_table.setItem(port_row_num, 0, QTableWidgetItem("✓"))
                        ports_table.setItem(port_row_num, 1, QTableWidgetItem(str(unique_data["port"])))
                        ports_table.setItem(port_row_num, 2, QTableWidgetItem(unique_data["protocol"]))
                        ports_table.setItem(port_row_num, 3, QTableWidgetItem(unique_data["status"]))
                        ports_table.setItem(port_row_num, 4, QTableWidgetItem(unique_data["service"]))

                        script_result_button = QPushButton("No Script Results")
                        script_result_button.setEnabled(False)
                        script_output = unique_data["script_output"]
                        script_list = []
                        if script_output:
                            for script_name, output in script_output.items():
                                if output:
                                    script_list += [script_name, output]
                                    script_result_button = QPushButton(f"Show Results: {script_name}") if len(script_list) <= 2 else QPushButton("Show Results")
                                    script_result_button.setEnabled(True)
                                    script_result_button.clicked.connect(lambda _, vl=script_list: self.show_vulns(vl))

                        ports_table.setCellWidget(port_row_num, 5, script_result_button)
                        ports_table.setItem(port_row_num, 6, QTableWidgetItem(unique_data["version"]))
                        ports_table.setItem(port_row_num, 7, QTableWidgetItem(unique_data["cpe"]))
                        ports_table.resizeColumnsToContents()
                        port_row_num += 1

if __name__ == "__main__":
    app = QApplication(sys.argv)
    main_window = NextgeNmapGUI()
    app.setStyle(QStyleFactory.create("Fusion"))
    main_window.show()
    sys.exit(app.exec())
