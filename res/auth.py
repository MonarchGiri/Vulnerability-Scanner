import sqlite3
import hashlib
import random
from datetime import datetime, timedelta
import re
import pyotp
from .email_utils import send_verification_email, send_scan_report_email


class Auth:
    def __init__(self, db_name='users.db'):
        self.db_name = db_name
        self.init_db()
        self.verification_codes = {}

    def init_db(self):
        """
        Initialize the database and create the users table if it doesn't exist.
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT UNIQUE,
                password TEXT,
                email TEXT UNIQUE,
                role TEXT,
                totp_secret TEXT,
                totp_enabled INTEGER DEFAULT 0
            )
        ''')
        conn.commit()
        conn.close()

    def hash_password(self, password):
        """
        Hash the password using SHA-256.
        :param password: str
        :return: str (hashed password)
        """
        return hashlib.sha256(password.encode()).hexdigest()

    def validate_user(self, email, password):
        """
        Validate if the provided email and password match a user in the database.
        :param email: str
        :param password: str
        :return: bool
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT password FROM users WHERE email = ?', (email,))
        result = c.fetchone()
        conn.close()
        if result and result[0] == self.hash_password(password):
            return True
        return False

    def get_user_role(self, email):
        """
        Get the role of a user from the database.
        :param email: str
        :return: str (role) or None
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT role FROM users WHERE email = ?', (email,))
        result = c.fetchone()
        conn.close()
        if result:
            return result[0]
        return None

    def add_user(self, username, password, email, role='user'):
        """
        Add a new user to the database.
        :param username: str
        :param password: str
        :param email: str
        :param role: str (default is 'user')
        :return: bool (True if user added successfully, False if username or email already exists)
        """
        if not self.validate_email(email) or not self.validate_password(password):
            return False

        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        try:
            c.execute('INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)', 
                    (username, self.hash_password(password), email, role))
            conn.commit()
            print(f"User added: {username}")  # Debug print statement
        except sqlite3.IntegrityError:
            return False
        finally:
            conn.close()
        return True

    def user_exists(self):
        """
        Check if any users exist in the database.
        :return: bool
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT COUNT(*) FROM users')
        result = c.fetchone()
        conn.close()
        return result[0] > 0

    def generate_verification_code(self):
        """
        Generate a 6-digit verification code.
        :return: str
        """
        return f"{random.randint(100000, 999999)}"

    def send_verification_email(self, email, code, username):
        """
        Send a verification email with the code using Gmail SMTP.
        :param email: str
        :param code: str
        :param username: str
        """
        try:
            sender_email = "vulnerabilityvanguards@gmail.com"  # Replace with your Gmail address
            password = "qlxi hnfc yzeo qxig"  # Replace with your Gmail password or App Password if using 2-Step Verification

            subject = "Email Verification Code"
            send_verification_email("smtp.gmail.com", 465, sender_email, email, password, subject, code, username)
        except Exception as e:
            print(f"Error sending email: {e}")

    def send_scan_report_email(self, email, attachment_path):
        """
        Send a scan report email with the report attached.
        :param email: str
        :param attachment_path: str
        """
        try:
            sender_email = "vulnerabilityvanguards@gmail.com"  # Replace with your Gmail address
            password = "qlxi hnfc yzeo qxig"  # Replace with your Gmail password or App Password if using 2-Step Verification

            subject = "Scan Report"
            username = self.get_username_by_email(email)  # Get the username
            if not username:
                username = "User"  # Fallback to a default value if username is not found
            print(f"Username fetched for scan report email: {username}")  # Debug print statement
            body = f"Dear {username},\n\nScanning complete. Please find attached scanning report."
            send_scan_report_email("smtp.gmail.com", 465, sender_email, email, password, subject, body, attachment_path)
        except Exception as e:
            print(f"Error sending email: {e}")

    def store_verification_code(self, email, code):
        """
        Store the verification code with a timestamp.
        :param email: str
        :param code: str
        """
        self.verification_codes[email] = (code, datetime.now() + timedelta(minutes=5))

    def verify_code(self, email, code):
        """
        Verify the provided code.
        :param email: str
        :param code: str
        :return: bool
        """
        if email in self.verification_codes:
            stored_code, expiry_time = self.verification_codes[email]
            if datetime.now() <= expiry_time and stored_code == code:
                del self.verification_codes[email]
                return True
        return False

    def validate_email(self, email):
        """
        Validate email format.
        :param email: str
        :return: bool
        """
        email_regex = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
        return re.match(email_regex, email) is not None

    def validate_password(self, password):
        """
        Validate password complexity.
        :param password: str
        :return: bool
        """
        if len(password) < 8:
            return False
        if not re.search(r'[A-Z]', password):
            return False
        if not re.search(r'[a-z]', password):
            return False
        if not re.search(r'[0-9]', password):
            return False
        if not re.search(r'[!@#\$%\^&\*]', password):
            return False
        return True

    def get_all_emails(self):
        """
        Get all emails from the database.
        :return: list of str
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT email FROM users')
        result = c.fetchall()
        conn.close()
        return [row[0] for row in result]

    def setup_totp(self, email):
        """
        Generate a TOTP secret for a user and return the provisioning URI.
        :param email: str
        :return: str (provisioning URI)
        """
        totp_secret = pyotp.random_base32()
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('UPDATE users SET totp_secret = ?, totp_enabled = 0 WHERE email = ?', (totp_secret, email))
        conn.commit()
        conn.close()

        totp = pyotp.TOTP(totp_secret)
        provisioning_uri = totp.provisioning_uri(name=email, issuer_name="VGuards")
        return provisioning_uri

    def verify_totp(self, email, totp_code):
        """
        Verify a TOTP code for a user.
        :param email: str
        :param totp_code: str
        :return: bool
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT totp_secret FROM users WHERE email = ?', (email,))
        result = c.fetchone()
        conn.close()

        if result:
            totp_secret = result[0]
            totp = pyotp.TOTP(totp_secret)
            return totp.verify(totp_code)
        return False

    def enable_totp(self, email):
        """
        Enable TOTP for a user after successful verification.
        :param email: str
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('UPDATE users SET totp_enabled = 1 WHERE email = ?', (email,))
        conn.commit()
        conn.close()

    def is_totp_enabled(self, email):
        """
        Check if TOTP is enabled for a user.
        :param email: str
        :return: bool
        """
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT totp_enabled FROM users WHERE email = ?', (email,))
        result = c.fetchone()
        conn.close()
        return result[0] == 1

    def reset_password(self, email, new_password):
        """
        Reset the password for a user.
        :param email: str
        :param new_password: str
        :return: bool
        """
        if not self.validate_password(new_password):
            return False

        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('UPDATE users SET password = ? WHERE email = ?', (self.hash_password(new_password), email))
        conn.commit()
        conn.close()
        return True

    def get_username_by_email(self, email):
        conn = sqlite3.connect(self.db_name)
        c = conn.cursor()
        c.execute('SELECT username FROM users WHERE email = ?', (email,))
        result = c.fetchone()
        conn.close()
        if result:
            print(f"Fetched username: {result[0]} for email: {email}")
            return result[0]
        else:
            print(f"No username found for email: {email}")
        return None


